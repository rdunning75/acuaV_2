"use strict";
// Copyright IBM Corp. 2019. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const debugFactory = require("debug");
const _ = require("lodash");
const debug = debugFactory('loopback:repository:relation-helpers');
/**
 * Finds model instances that contain any of the provided foreign key values.
 *
 * @param targetRepository - The target repository where the model instances are found
 * @param fkName - Name of the foreign key
 * @param fkValues - One value or array of values of the foreign key to be included
 * @param scope - Additional scope constraints (not currently supported)
 * @param options - Options for the operations
 */
async function findByForeignKeys(targetRepository, fkName, fkValues, scope, options) {
    // throw error if scope is defined and non-empty
    // see https://github.com/strongloop/loopback-next/issues/3453
    if (scope && !_.isEmpty(scope)) {
        throw new Error('scope is not supported');
    }
    let value;
    if (Array.isArray(fkValues)) {
        if (fkValues.length === 0)
            return [];
        value = fkValues.length === 1 ? fkValues[0] : { inq: fkValues };
    }
    else {
        value = fkValues;
    }
    const where = { [fkName]: value };
    const targetFilter = { where };
    return targetRepository.find(targetFilter, options);
}
exports.findByForeignKeys = findByForeignKeys;
/**
 * Returns model instances that include related models that have a registered
 * resolver.
 *
 * @param targetRepository - The target repository where the model instances are found
 * @param entities - An array of entity instances or data
 * @param include -Inclusion filter
 * @param options - Options for the operations
 */
async function includeRelatedModels(targetRepository, entities, include, options) {
    const result = entities;
    if (!include)
        return result;
    const invalidInclusions = include.filter(inclusionFilter => !isInclusionAllowed(targetRepository, inclusionFilter));
    if (invalidInclusions.length) {
        const msg = 'Invalid "filter.include" entries: ' +
            invalidInclusions
                .map(inclusionFilter => JSON.stringify(inclusionFilter))
                .join('; ');
        const err = new Error(msg);
        Object.assign(err, {
            code: 'INVALID_INCLUSION_FILTER',
        });
        throw err;
    }
    const resolveTasks = include.map(async (inclusionFilter) => {
        const relationName = inclusionFilter.relation;
        const resolver = targetRepository.inclusionResolvers.get(relationName);
        const targets = await resolver(entities, inclusionFilter, options);
        result.forEach((entity, ix) => {
            const src = entity;
            src[relationName] = targets[ix];
        });
    });
    await Promise.all(resolveTasks);
    return result;
}
exports.includeRelatedModels = includeRelatedModels;
/**
 * Checks if the resolver of the inclusion relation is registered
 * in the inclusionResolver of the target repository
 *
 * @param targetRepository - The target repository where the relations are registered
 * @param include - Inclusion filter
 */
function isInclusionAllowed(targetRepository, include) {
    const relationName = include.relation;
    if (!relationName) {
        debug('isInclusionAllowed for %j? No: missing relation name', include);
        return false;
    }
    const allowed = targetRepository.inclusionResolvers.has(relationName);
    debug('isInclusionAllowed for %j (relation %s)? %s', include, allowed);
    return allowed;
}
//# sourceMappingURL=relation.helpers.js.map